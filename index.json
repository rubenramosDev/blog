[{"content":"Introducci√≥n al monitoreo de aplicaciones, ¬øPara qu√© tomarse la molestia? En el mundo de los microservicios (y en general, en cualquier arquitectura) es de suma importancia conocer el estado de los servicios en funcionamiento.\nCuando menciono estado, me refiero a la capacidad de responder a preguntas del tipo ¬øCu√°ntas peticiones por minuto se reciben?, ¬øCu√°l es el tiempo de respuesta promedio?, ¬øCu√°l es el porcentaje de errores por minuto?, ¬øCu√°l es el endpoint m√°s solicitado?, ¬øCu√°l es el n√∫mero de peticiones activas?.\nA la supervisi√≥n continua de un conjunto de m√©tricas de rendimiento (o de cualquier tipo), se le conoce como monitoreo de aplicaciones.\nSi bien, el simple hecho de monitorear nuestras aplicaciones no evita que est√°s puedan colapsar o que los tiempos de respuesta se degraden en ciertas horas del d√≠a, s√≠ nos brinda la capacidad de conocer con exactitud cu√°l es su estado y eventualmente, la capacidad de gestionar nuestro conjunto de servicios mediante la toma de acciones preventivas o correctivas, como puede ser el despliegue de servidores extras en ciertas horas del d√≠a o la implementaci√≥n de un balanceador de carga por monitoreo, etc.\nTodo esto con un objetivo √∫nico, garantizar un funcionamiento √≥ptimo e ininterrumpido de nuestros servicios y, naturalmente, una buena experiencia para el usuario final.\nBeneficios del monitoreo Google ha realizado numerosos esfuerzos para propagar la cultura del monitoreo, existen innumerables fuentes de informaci√≥n y documentaci√≥n generada por ellos mismos, en donde comparten sus experiencias en el √°rea y sus recomendaciones.\nEn esta secci√≥n voy a retomar el apartado Why Monitor? del art√≠culo Monitoring Distributed Systems [1]. Extiendo mi amplia recomendaci√≥n para la consulta de este art√≠culo que es, sin duda, muy enriquecedor.\nMe centrar√© en 4 puntos claves que considero los m√°s redituables del monitoreo de nuestros servicios:\nAn√°lisis de tendencias a largo plazo Tener un hist√≥rico de un valor nos permite realizar proyecciones del mismo. Por ejemplo, ¬øCu√°l es la tendencia de ventas de cierto art√≠culo? o ¬øCu√°l es la proyecci√≥n de ventas? Realizar comparaciones en diferentes per√≠odos de tiempo ¬øCu√°l es la cantidad de peticiones recibidas en el mismo per√≠odo del a√±o pasado? ¬øCu√°l es la comparativa de ventas en diferentes √©pocas del a√±o? An√°lisis retrospectivo de sucesos Supongamos que esperabamos realizar un cierto n√∫mero de ventas en un fin de semana clave para nuestro negocio pero el objetivo qued√≥ muy por debajo del esperado. ¬øQu√© sucedi√≥? ¬øNuestros servicios fueron factor? Bueno, gracias al monitereo que estamos realizando podemos analizar el rendimiento de nuestros servicios, saber si estos estuvieron recibiendo un tr√°fico excesivo que termin√≥ por afectar su rendimiento, otro escenario ser√≠a si nuestros proveedores externos experimentaron fallas en su sistema que termin√≥ por afectar a la experiencia de usuario de nuestros clientes y eso, a su vez, al n√∫mero de ventas. Alertas Retomando el ejemplo anterior, ¬øEs necesario esperar a que nuestros sistemas colapsen para poder hacer algo al respecto? La respuesta es un rotundo no. Un gran poder que nos brinda el monitereo es el tema de las Alertas. Gracias al monitoreo, seremos capaces de establecer reglas que nos permitan identificar tendencias dentro de nuestro sistema para poder actuar con antelaci√≥n. Por ejemplo, si el tiempo de respuesta comienza a degradarse, una alerta llegar√° a los encargados para que estos puedan desplegar un servicio extra y aliviar el estr√©s.\nEn un segundo art√≠culo de esta serie, estar√© abordando el tema de Alertmanager que es una herramienta de Prometheus cuyo prop√≥sito es el de controlar y gestionar las alertas que fijemos en nuestro sistema. Prometheus, el rey del monitoreo. Prometheus es un sistema de monitoreo de c√≥digo abierto cuyo principal funci√≥n se centra en recopilar, almacenar y por √∫ltimo, exponer la informaci√≥n de un conjunto de servicios.\nSi bien, esta serie de art√≠culos se centrar√° en el monitoreo de microservicios, Prometheus puede monitorear cualquier otro servicio capaz de exponer sus m√©tricas, siempre y cuando esta informaci√≥n cuente con un formato espec√≠fico. Un ejemplo de otros servicios, en donde es posible y ser√≠a interesante el monitoreo, es en los servidores Linux, Windows, NGINX o servicios como Kafka o bases de datos como MySQL, SQL Server, etc.\nLa siguiente imagen es un ejemplo del tipo de resultados que se pueden obtener de la mano de Prometheus y Grafana. En donde Prometheus es el encargado de consolidar la informaci√≥n de los servicios y Grafana es el encargado de la parte visual, la generaci√≥n de gr√°ficos y dashboards. Entendiendo su arquitectura y funcionamiento La siguiente imagen muestra la arquitectura de Prometheus de forma muy general, no obstante, nos ayuda a comprender su funcionamiento interno.\nComo se mencion√≥ anteriormente, Prometheus nos ayuda a recopilar, almacenar y exponer las m√©tricas obtenidas de nuestros servicios. Para entender c√≥mo se lleva a cabo este proceso analicemos la siguiente imagen: Retrival: Es un motor de scrapping encargado de recolectar la informaci√≥n de los diferentes servicios (conocidos como Jobs) que nos interesa monitorear. En un intervalo de tiempo definido por nosotros, por ejemplo, cada 20 segundos, 2 o 5 minutos, este motor se encargar√° de consultar los servicios registrados para recolectar su informaci√≥n. Los intervalos de tiempo pueden ser generales para todos los Jobs o cada Job puede tener un tiempo particular.\nTime series database o TSDB: Una vez que la informaci√≥n ha sido recolectada, Prometheus almacena la misma en una base de datos de tipo Time series (se explica m√°s adelante). De forma nativa, Prometheus ya cuenta con la integraci√≥n de una base de datos para almacenar la informaci√≥n de forma local, en disco. No obstante, se pueden integrar alternativas para almacenar la informaci√≥n de forma remota.\nHTTP Server: Prometheus cuenta con un servidor HTTP integrado. Este servidor expone la informaci√≥n previamente recolectada y almacenada por medio de una ruta http, /metrics. Con la informaci√≥n disponible para ser consultada de esta manera, se pueden utilizar m√∫ltiples aplicaciones especializadas para la creaci√≥n de gr√°ficos, como puede ser Grafana.\nM√©tricas, ¬øQu√© son? En el sitio oficial de Prometheus, se presenta la siguiente definici√≥n:\nIn layperson terms, metrics are numeric measurements. Time series means that changes are recorded over time.\nSin m√°s, una m√©trica es una medici√≥n num√©rica.\nNo obstante la definici√≥n va m√°s all√° de eso y nos comienza a introducir un concepto clave de Prometheus y es Time series, en espa√±ol Serie Temporal. De manera general, una serie temporal es una sucesi√≥n de datos que han sido recabados en diferentes momentos y ordenados cronol√≥gicamente.\nLa siguiente imagen nos puede ayudar a entender de mejor manera el concepto, se trata de una animaci√≥n del tipo de gr√°fica que se puede lograr con una serie temporal: Gracias a la forma en que se recolecta y organiza la informaci√≥n, se puede lograr ver las tendencias o comportamiento de ciertos valores, por ejemplo, el porcentaje de ventas en cierto per√≠odo del a√±o o el nivel de carga de nuestros servicios en diferentes horas del d√≠a, etc.\nFormato de las m√©tricas, ¬øC√≥mo esta compuesta una m√©trica? Ahora que ya tenemos un contexto m√°s amplio acerca de Prometheus, es momento de entrar en detalles m√°s t√©cnicos. Como fue mencionado anteriormente, Prometheus puede recolectar la informaci√≥n de m√∫ltiples servicios, poco importa si se trata de un microservicio o un servidor Linux, la √∫nica condici√≥n es que esta informaci√≥n tenga un formato espec√≠fico para que pueda ser interpretada, recolectada y almacenada eventualmente.\nEn la documentaci√≥n oficial de Prometheus [2], se brinda el siguiente ejemplo para demostrar la composici√≥n de una m√©trica:\n\u0026lt;nombre de la m√©trica\u0026gt;{\u0026lt;nombre etiqueta\u0026gt;=\u0026lt;valor de la etiqueta\u0026gt;, ...} A continuaci√≥n, vamos a analizar una m√©trica real que se obtuvo de un microservicio. En este caso, el objetivo de la m√©trica es dar a conocer el n√∫mero de peticiones que se encuentran activas en el servidor:\napplication_httprequests_active{server=\u0026#34;SERVIDOR-EJEMPLO\u0026#34;} 3 application_httprequests_active: Nombre de la m√©trica. server=SERVIDOR-EJEMPLO: Este valor es conocido como una etiqueta o label. Una etiqueta es informaci√≥n complementaria para precisar o identificar de mejor manera el origen de la informaci√≥n, adelante veremos m√°s ejemplos. 3 : Valor de la m√©trica. Con esta m√©trica, podemos entender que en el servidor con nombre \u0026ldquo;SERVIDOR-EJEMPLO\u0026rdquo; se encuentran 3 peticiones activas en el momento en que fue consultado.\nTipos de m√©tricas Prometheus implementa 4 tipos de m√©tricas diferentes para almacenar su informaci√≥n:\nCounter Counter representa el tipo de medici√≥n cuyo valor es solamente acumulativo, es decir, incrementa y no disminuye. Ejemplos: N√∫mero de peticiones a un servicio, n√∫m. de errores o las ventas de alg√∫n producto.\napplication_httprequests_error_rate_per_endpoint_total{route=\u0026#34;GET\u0026#34;,server=\u0026#34;SERVIDOR-EJEMPLO\u0026#34;,app=\u0026#34;NombreDeTuServicio\u0026#34;,env=\u0026#34;development\u0026#34;} 2 Gauge Este tipo de m√©trica representa a un valor que puede incrementar o disminuir de manera arbitraria. Es muy similiar a Counter, con la diferencia de que este valor s√≠ puede disminuir. Ejemplos: Porcentaje de errores por minuto, N√∫m. de peticiones activas o el uso de memoria de un servicio.\napplication_httprequests_one_minute_error_percentage_rate{server=\u0026#34;SERVIDOR-EJEMPLO\u0026#34;,app=\u0026#34;NombreDeTuServicio\u0026#34;,env=\u0026#34;development\u0026#34;} 22.126200053643398 Histograms Un histograma es una representaci√≥n que permite realizar la distribuci√≥n o categorizaci√≥n de un conjunto de datos. Por ejemplo, con ayuda de un histograma podemos saber cu√°ntos valores fueron bajos, cu√°ntos valores fueron medios y cu√°ntos altos.\nHistogram se utiliza comunmente para monitorear el tama√±o de ciertos eventos. Los casos de uso m√°s comunes es para medir el tiempo de las peticiones o el tama√±o de la mismas. Este tipo de m√©trica toma diferentes observaciones de una m√©trica en diferentes momentos u observe y se colocan en un Bucket. Un bucket es una agrupaci√≥n de informaci√≥n predefinida por nosotros (para este ejemplo, 10, 20, 50).\nEn Prometheus, los buckets se ver√≠an de la siguiente manera: Cada bucket es mayor que el anterior, es decir, sus valores son acumulativos. En este ejemplo, el segundo bucket esta compuesto por la suma de sus valores, m√°s los valores del primero bucket y el tercero, esta compuesto por la suma del segundo y primer bucket.\n_sum y _count por lo general se encuentran presentes en este tipo de m√©trica. Los 2 campos son valores contadores:\n_count incrementa 1 con cada observe. _sum se incrementa con el valor de la observaci√≥n obtenida. application_http_request_duration_seconds_bucket{server=\u0026#34;SERVIDOR-EJEMPLO\u0026#34;, app=\u0026#34;NombreDeTuServicio\u0026#34;,env=\u0026#34;development\u0026#34;, handler=\u0026#34;/\u0026#34;,le=\u0026#34;0.1\u0026#34;} 25688 application_http_request_duration_seconds_bucket{server=\u0026#34;SERVIDOR-EJEMPLO\u0026#34;, app=\u0026#34;NombreDeTuServicio\u0026#34;,env=\u0026#34;development\u0026#34;, handler=\u0026#34;/\u0026#34;,le=\u0026#34;0.2\u0026#34;} 23688 application_http_request_duration_seconds_bucket{server=\u0026#34;SERVIDOR-EJEMPLO\u0026#34;, app=\u0026#34;NombreDeTuServicio\u0026#34;,env=\u0026#34;development\u0026#34;, handler=\u0026#34;/\u0026#34;,le=\u0026#34;0.4\u0026#34;} 28782 application_http_request_duration_seconds_bucket{server=\u0026#34;SERVIDOR-EJEMPLO\u0026#34;, app=\u0026#34;NombreDeTuServicio\u0026#34;,env=\u0026#34;development\u0026#34;, handler=\u0026#34;/\u0026#34;,le=\u0026#34;+Inf\u0026#34;} 29000 application_http_request_duration_seconds_sum{server=\u0026#34;SERVIDOR-EJEMPLO\u0026#34;, app=\u0026#34;NombreDeTuServicio\u0026#34;,env=\u0026#34;development\u0026#34;, handler=\u0026#34;/\u0026#34;} 1974.90592036741 application_http_request_duration_seconds_count{server=\u0026#34;SERVIDOR-EJEMPLO\u0026#34;, app=\u0026#34;NombreDeTuServicio\u0026#34;,env=\u0026#34;development\u0026#34;, handler=\u0026#34;/\u0026#34;} 29020 le significa less than or equal, es decir, igual o menos. Por lo cu√°l, esta m√©trica se puede entender:\n25688 peticiones tomaron igual o menos de 100 milisegundos (ms). 23688 peticiones tomaron igual o menos de 200 milisegundos (ms). 28782 peticiones tomaron igual o menos de 400 milisegundos (ms). En total han habido 29020 peticiones. Summary Esta m√©trica comparte muchas similitudes con Histogram. Se recomienda su uso en los siguientes escenarios:\nCon los Histograms, los quantiles de una m√©trica son calculados por Prometheus. Con los Summaries, estos valores son calculados en lado del cliente. Si no se tiene una idea clara sobre las definiciones de los buckets o como segmentar un valor, Summary es mejor alternativa, debido a que los histograms necesitan de definiciones de buckets de manera forzosa. Recomiendo consultar la documentaci√≥n de Prometheus en d√≥nde se aborda el tema a detalle.\n¬øQu√© monitorear? ¬øC√≥mo? ¬øCu√°ndo? - The Four Golden Signals ¬øEs realmente importante monitorear el nombre de un servidor? O, ¬øEl nombre de los endpoints? Quiz√°s s√≠ o quiz√°s no, algunas m√©tricas tendr√°n m√°s sentido para una organizaci√≥n que para otra, lo importante entonces es dise√±ar un plan de monitoreo en d√≥nde se defina claramente: ¬øQu√© se va a monitorear y para qu√©? Es de suma importancia, sobre todo si se estar√° recopilando informaci√≥n que ata√±e a diferentes √°reas, como por ejemplo, el n√∫mero de ventas de un producto, el n√∫mero de fallas de los proveedores externos o el tiempo de respuesta de un determinado endpoint, si bien, estos valores pueden estar relacionados, su informaci√≥n y atenci√≥n no necesariamente pertenece a la misma √°rea dentro de una organizaci√≥n.\nEn esta secci√≥n me remito de nueva cuenta al art√≠culo Monitoring Distributed Systems [1] en donde se plantean 4 puntos fundamentales que deben ser considerados s√≠ o s√≠ en el monitoreo de nuestros sistemas.\nLatencia\n¬øEn cu√°nto tiempo se est√°n resolviendo las peticiones del cliente? El art√≠culo menciona algo clave, es importante tener cuidado y fijar un sesgo muy claro en este punto, ¬° Los posibles errores que se generen en nuestro sistema no forman parte de la latencia del mismo ! Si nuestro sistema responde en ocasiones con una rapidez de 10ms porque se esta presentando un error, esto no quiere decir que sea r√°pido üòÖ. Tr√°fico\n¬øCu√°l es el n√∫mero de peticiones que esta recibiendo nuestro sistema? ¬øCu√°l es el promedio por minuto? Errores\n¬øCu√°ntos errores se est√°n generando? ¬øCu√°l es la tasa de error por minuto? Saturaci√≥n\n¬øQu√© tanta carga tiene el sistema? ¬øQu√© tan saturado se encuentra? Hasta aqu√≠ el contenido de esta serie de art√≠culos. En un siguiente art√≠culo se estar√° cubriendo temas m√°s t√©cnicos de Prometheus como PromQL, el archivo de configuraci√≥n y Alertmanager, entre otros temas.\nReferencias [1] Monitoring Distributed Systems by Rob Ewaschuk\n[2] Histograms and summaries\n[3] Data model\n","permalink":"https://rubenramosdev.github.io/post/prometheus-basics-1/","summary":"Introducci√≥n, conceptos clave y explicaci√≥n del funcionamiento de esta herramienta para el monitoreo de servicios.","title":"Monitereo de servicios con Prometheus | 1"},{"content":" Mi nombre es Rub√©n Ramos, en este blog escribo sobre promgramaci√≥n, ingener√≠a y arquitectura de software.\nMe apasiona el desarrollo de software, las nuevas tecnolog√≠as y el impacto de est√°s en nuestro mundo.\nCont√°ctame\nrubenramos.blog@gmail.com\nLinkedIn Github\n","permalink":"https://rubenramosdev.github.io/about-me/","summary":"About me","title":"About me"}]